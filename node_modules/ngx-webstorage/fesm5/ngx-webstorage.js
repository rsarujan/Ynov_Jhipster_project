import { filter, switchMap, distinctUntilChanged, shareReplay, map } from 'rxjs/operators';
import { __decorate, __extends, __param, __metadata, __spread } from 'tslib';
import { ɵɵdefineInjectable, Injectable, InjectionToken, Inject, PLATFORM_ID, NgZone, Optional, ɵɵinject, APP_INITIALIZER, NgModule } from '@angular/core';
import { Subject, of } from 'rxjs';
import { isPlatformBrowser } from '@angular/common';

var StorageStrategies;
(function (StorageStrategies) {
    StorageStrategies["Local"] = "local_strategy";
    StorageStrategies["Session"] = "session_strategy";
    StorageStrategies["InMemory"] = "in_memory_strategy";
})(StorageStrategies || (StorageStrategies = {}));

var CompatHelper = /** @class */ (function () {
    function CompatHelper() {
    }
    CompatHelper.isStorageAvailable = function (storage) {
        var available = true;
        try {
            if (typeof storage === 'object') {
                storage.setItem('test-storage', 'foobar');
                storage.removeItem('test-storage');
            }
            else
                available = false;
        }
        catch (e) {
            available = false;
        }
        return available;
    };
    return CompatHelper;
}());

function noop() { }

var DefaultPrefix = 'ngx-webstorage';
var DefaultSeparator = '|';
var DefaultIsCaseSensitive = false;

var StorageKeyManager = /** @class */ (function () {
    function StorageKeyManager() {
    }
    StorageKeyManager.normalize = function (raw) {
        raw = StorageKeyManager.isCaseSensitive ? raw : raw.toLowerCase();
        return "" + StorageKeyManager.prefix + StorageKeyManager.separator + raw;
    };
    StorageKeyManager.isNormalizedKey = function (key) {
        return key.indexOf(StorageKeyManager.prefix + StorageKeyManager.separator) === 0;
    };
    StorageKeyManager.setPrefix = function (prefix) {
        StorageKeyManager.prefix = prefix;
    };
    StorageKeyManager.setSeparator = function (separator) {
        StorageKeyManager.separator = separator;
    };
    StorageKeyManager.setCaseSensitive = function (enable) {
        StorageKeyManager.isCaseSensitive = enable;
    };
    StorageKeyManager.consumeConfiguration = function (config) {
        if ('prefix' in config)
            this.setPrefix(config.prefix);
        if ('separator' in config)
            this.setSeparator(config.separator);
        if ('caseSensitive' in config)
            this.setCaseSensitive(config.caseSensitive);
    };
    StorageKeyManager.prefix = DefaultPrefix;
    StorageKeyManager.separator = DefaultSeparator;
    StorageKeyManager.isCaseSensitive = DefaultIsCaseSensitive;
    return StorageKeyManager;
}());

var SyncStorage = /** @class */ (function () {
    function SyncStorage(strategy) {
        this.strategy = strategy;
    }
    SyncStorage.prototype.retrieve = function (key) {
        var value;
        this.strategy.get(StorageKeyManager.normalize(key)).subscribe(function (result) { return value = typeof result === 'undefined' ? null : result; });
        return value;
    };
    SyncStorage.prototype.store = function (key, value) {
        this.strategy.set(StorageKeyManager.normalize(key), value).subscribe(noop);
        return value;
    };
    SyncStorage.prototype.clear = function (key) {
        if (key !== undefined)
            this.strategy.del(StorageKeyManager.normalize(key)).subscribe(noop);
        else
            this.strategy.clear().subscribe(noop);
    };
    SyncStorage.prototype.getStrategyName = function () { return this.strategy.name; };
    SyncStorage.prototype.observe = function (key) {
        var _this = this;
        key = StorageKeyManager.normalize(key);
        return this.strategy.keyChanges.pipe(filter(function (changed) { return changed === null || changed === key; }), switchMap(function () { return _this.strategy.get(key); }), distinctUntilChanged(), shareReplay());
    };
    return SyncStorage;
}());

var AsyncStorage = /** @class */ (function () {
    function AsyncStorage(strategy) {
        this.strategy = strategy;
    }
    AsyncStorage.prototype.retrieve = function (key) {
        return this.strategy.get(StorageKeyManager.normalize(key)).pipe(map(function (value) { return typeof value === 'undefined' ? null : value; }));
    };
    AsyncStorage.prototype.store = function (key, value) {
        return this.strategy.set(StorageKeyManager.normalize(key), value);
    };
    AsyncStorage.prototype.clear = function (key) {
        return key !== undefined ? this.strategy.del(StorageKeyManager.normalize(key)) : this.strategy.clear();
    };
    AsyncStorage.prototype.getStrategyName = function () { return this.strategy.name; };
    AsyncStorage.prototype.observe = function (key) {
        var _this = this;
        key = StorageKeyManager.normalize(key);
        return this.strategy.keyChanges.pipe(filter(function (changed) { return changed === null || changed === key; }), switchMap(function () { return _this.strategy.get(key); }), distinctUntilChanged(), shareReplay());
    };
    return AsyncStorage;
}());

var StrategyCacheService = /** @class */ (function () {
    function StrategyCacheService() {
        this.caches = {};
    }
    StrategyCacheService.prototype.get = function (strategyName, key) {
        return this.getCacheStore(strategyName)[key];
    };
    StrategyCacheService.prototype.set = function (strategyName, key, value) {
        this.getCacheStore(strategyName)[key] = value;
    };
    StrategyCacheService.prototype.del = function (strategyName, key) {
        delete this.getCacheStore(strategyName)[key];
    };
    StrategyCacheService.prototype.clear = function (strategyName) {
        this.caches[strategyName] = {};
    };
    StrategyCacheService.prototype.getCacheStore = function (strategyName) {
        if (strategyName in this.caches)
            return this.caches[strategyName];
        return this.caches[strategyName] = {};
    };
    StrategyCacheService.ɵprov = ɵɵdefineInjectable({ factory: function StrategyCacheService_Factory() { return new StrategyCacheService(); }, token: StrategyCacheService, providedIn: "root" });
    StrategyCacheService = __decorate([
        Injectable({ providedIn: 'root' })
    ], StrategyCacheService);
    return StrategyCacheService;
}());

var LOCAL_STORAGE = new InjectionToken('window_local_storage');
function getLocalStorage() {
    return (typeof window !== 'undefined') ? window.localStorage : null;
}
var LocalStorageProvider = { provide: LOCAL_STORAGE, useFactory: getLocalStorage };
var SESSION_STORAGE = new InjectionToken('window_session_storage');
function getSessionStorage() {
    return (typeof window !== 'undefined') ? window.sessionStorage : null;
}
var SessionStorageProvider = { provide: SESSION_STORAGE, useFactory: getSessionStorage };

var BaseSyncStorageStrategy = /** @class */ (function () {
    function BaseSyncStorageStrategy(storage, cache) {
        this.storage = storage;
        this.cache = cache;
        this.keyChanges = new Subject();
    }
    Object.defineProperty(BaseSyncStorageStrategy.prototype, "isAvailable", {
        get: function () {
            if (this._isAvailable === undefined)
                this._isAvailable = CompatHelper.isStorageAvailable(this.storage);
            return this._isAvailable;
        },
        enumerable: true,
        configurable: true
    });
    BaseSyncStorageStrategy.prototype.get = function (key) {
        var data = this.cache.get(this.name, key);
        if (data !== undefined)
            return of(data);
        try {
            var item = this.storage.getItem(key);
            if (item !== null) {
                data = JSON.parse(item);
                this.cache.set(this.name, key, data);
            }
        }
        catch (err) {
            console.warn(err);
        }
        return of(data);
    };
    BaseSyncStorageStrategy.prototype.set = function (key, value) {
        var data = JSON.stringify(value);
        this.storage.setItem(key, data);
        this.cache.set(this.name, key, value);
        this.keyChanges.next(key);
        return of(value);
    };
    BaseSyncStorageStrategy.prototype.del = function (key) {
        this.storage.removeItem(key);
        this.cache.del(this.name, key);
        this.keyChanges.next(key);
        return of(null);
    };
    BaseSyncStorageStrategy.prototype.clear = function () {
        this.storage.clear();
        this.cache.clear(this.name);
        this.keyChanges.next(null);
        return of(null);
    };
    return BaseSyncStorageStrategy;
}());

var LocalStorageStrategy = /** @class */ (function (_super) {
    __extends(LocalStorageStrategy, _super);
    function LocalStorageStrategy(storage, cache, platformId, zone) {
        var _this = _super.call(this, storage, cache) || this;
        _this.storage = storage;
        _this.cache = cache;
        _this.platformId = platformId;
        _this.zone = zone;
        _this.name = LocalStorageStrategy_1.strategyName;
        if (isPlatformBrowser(_this.platformId))
            _this.listenExternalChanges();
        return _this;
    }
    LocalStorageStrategy_1 = LocalStorageStrategy;
    LocalStorageStrategy.prototype.listenExternalChanges = function () {
        var _this = this;
        window.addEventListener('storage', function (event) { return _this.zone.run(function () {
            if (event.storageArea !== _this.storage)
                return;
            var key = event.key;
            if (key !== null)
                _this.cache.del(_this.name, event.key);
            else
                _this.cache.clear(_this.name);
            _this.keyChanges.next(key);
        }); });
    };
    var LocalStorageStrategy_1;
    LocalStorageStrategy.strategyName = StorageStrategies.Local;
    LocalStorageStrategy.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [LOCAL_STORAGE,] }] },
        { type: StrategyCacheService },
        { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
        { type: NgZone }
    ]; };
    LocalStorageStrategy = LocalStorageStrategy_1 = __decorate([
        Injectable(),
        __param(0, Inject(LOCAL_STORAGE)),
        __param(2, Inject(PLATFORM_ID)),
        __metadata("design:paramtypes", [Object, StrategyCacheService, Object, NgZone])
    ], LocalStorageStrategy);
    return LocalStorageStrategy;
}(BaseSyncStorageStrategy));

var SessionStorageStrategy = /** @class */ (function (_super) {
    __extends(SessionStorageStrategy, _super);
    function SessionStorageStrategy(storage, cache, platformId, zone) {
        var _this = _super.call(this, storage, cache) || this;
        _this.storage = storage;
        _this.cache = cache;
        _this.platformId = platformId;
        _this.zone = zone;
        _this.name = SessionStorageStrategy_1.strategyName;
        if (isPlatformBrowser(_this.platformId))
            _this.listenExternalChanges();
        return _this;
    }
    SessionStorageStrategy_1 = SessionStorageStrategy;
    SessionStorageStrategy.prototype.listenExternalChanges = function () {
        var _this = this;
        window.addEventListener('storage', function (event) { return _this.zone.run(function () {
            if (event.storageArea !== _this.storage)
                return;
            var key = event.key;
            if (event.key !== null)
                _this.cache.del(_this.name, event.key);
            else
                _this.cache.clear(_this.name);
            _this.keyChanges.next(key);
        }); });
    };
    var SessionStorageStrategy_1;
    SessionStorageStrategy.strategyName = StorageStrategies.Session;
    SessionStorageStrategy.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [SESSION_STORAGE,] }] },
        { type: StrategyCacheService },
        { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
        { type: NgZone }
    ]; };
    SessionStorageStrategy = SessionStorageStrategy_1 = __decorate([
        Injectable(),
        __param(0, Inject(SESSION_STORAGE)),
        __param(2, Inject(PLATFORM_ID)),
        __metadata("design:paramtypes", [Object, StrategyCacheService, Object, NgZone])
    ], SessionStorageStrategy);
    return SessionStorageStrategy;
}(BaseSyncStorageStrategy));

var InMemoryStorageStrategy = /** @class */ (function () {
    function InMemoryStorageStrategy(cache) {
        this.cache = cache;
        this.keyChanges = new Subject();
        this.isAvailable = true;
        this.name = InMemoryStorageStrategy_1.strategyName;
    }
    InMemoryStorageStrategy_1 = InMemoryStorageStrategy;
    InMemoryStorageStrategy.prototype.get = function (key) {
        return of(this.cache.get(this.name, key));
    };
    InMemoryStorageStrategy.prototype.set = function (key, value) {
        this.cache.set(this.name, key, value);
        this.keyChanges.next(key);
        return of(value);
    };
    InMemoryStorageStrategy.prototype.del = function (key) {
        this.cache.del(this.name, key);
        this.keyChanges.next(key);
        return of(null);
    };
    InMemoryStorageStrategy.prototype.clear = function () {
        this.cache.clear(this.name);
        this.keyChanges.next(null);
        return of(null);
    };
    var InMemoryStorageStrategy_1;
    InMemoryStorageStrategy.strategyName = StorageStrategies.InMemory;
    InMemoryStorageStrategy.ctorParameters = function () { return [
        { type: StrategyCacheService, decorators: [{ type: Inject, args: [StrategyCacheService,] }] }
    ]; };
    InMemoryStorageStrategy = InMemoryStorageStrategy_1 = __decorate([
        Injectable(),
        __param(0, Inject(StrategyCacheService)),
        __metadata("design:paramtypes", [StrategyCacheService])
    ], InMemoryStorageStrategy);
    return InMemoryStorageStrategy;
}());

var STORAGE_STRATEGIES = new InjectionToken('STORAGE_STRATEGIES');
var Strategies = [
    { provide: STORAGE_STRATEGIES, useClass: InMemoryStorageStrategy, multi: true },
    { provide: STORAGE_STRATEGIES, useClass: LocalStorageStrategy, multi: true },
    { provide: STORAGE_STRATEGIES, useClass: SessionStorageStrategy, multi: true },
];

var StorageStrategyStubName = 'stub_strategy';
var StorageStrategyStub = /** @class */ (function () {
    function StorageStrategyStub(name) {
        this.keyChanges = new Subject();
        this.store = {};
        this._available = true;
        this.name = name || StorageStrategyStubName;
    }
    Object.defineProperty(StorageStrategyStub.prototype, "isAvailable", {
        get: function () {
            return this._available;
        },
        enumerable: true,
        configurable: true
    });
    StorageStrategyStub.prototype.get = function (key) {
        return of(this.store[key]);
    };
    StorageStrategyStub.prototype.set = function (key, value) {
        this.store[key] = value;
        this.keyChanges.next(key);
        return of(value);
    };
    StorageStrategyStub.prototype.del = function (key) {
        delete this.store[key];
        this.keyChanges.next(key);
        return of(null);
    };
    StorageStrategyStub.prototype.clear = function () {
        this.store = {};
        this.keyChanges.next(null);
        return of(null);
    };
    return StorageStrategyStub;
}());

var StorageStub = /** @class */ (function () {
    function StorageStub() {
        this.store = {};
    }
    Object.defineProperty(StorageStub.prototype, "length", {
        get: function () {
            return Object.keys(this.store).length;
        },
        enumerable: true,
        configurable: true
    });
    StorageStub.prototype.clear = function () {
        this.store = {};
    };
    StorageStub.prototype.getItem = function (key) {
        return this.store[key] || null;
    };
    StorageStub.prototype.key = function (index) {
        return Object.keys(this.store)[index];
    };
    StorageStub.prototype.removeItem = function (key) {
        delete this.store[key];
    };
    StorageStub.prototype.setItem = function (key, value) {
        this.store[key] = value;
    };
    return StorageStub;
}());

var InvalidStrategyError = 'invalid_strategy';
var StrategyIndex = /** @class */ (function () {
    function StrategyIndex(strategies) {
        this.strategies = strategies;
        this.registration$ = new Subject();
        if (!strategies)
            strategies = [];
        this.strategies = strategies.reverse()
            .map(function (strategy, index, arr) { return strategy.name; })
            .map(function (name, index, arr) { return arr.indexOf(name) === index ? index : null; })
            .filter(function (index) { return index !== null; })
            .map(function (index) { return strategies[index]; });
    }
    StrategyIndex_1 = StrategyIndex;
    StrategyIndex.get = function (name) {
        if (!this.isStrategyRegistered(name))
            throw Error(InvalidStrategyError);
        var strategy = this.index[name];
        if (!strategy.isAvailable) {
            strategy = this.index[StorageStrategies.InMemory];
        }
        return strategy;
    };
    StrategyIndex.set = function (name, strategy) {
        this.index[name] = strategy;
    };
    StrategyIndex.clear = function (name) {
        if (name !== undefined)
            delete this.index[name];
        else
            this.index = {};
    };
    StrategyIndex.isStrategyRegistered = function (name) {
        return name in this.index;
    };
    StrategyIndex.hasRegistredStrategies = function () {
        return Object.keys(this.index).length > 0;
    };
    StrategyIndex.prototype.getStrategy = function (name) {
        return StrategyIndex_1.get(name);
    };
    StrategyIndex.prototype.indexStrategies = function () {
        var _this = this;
        this.strategies.forEach(function (strategy) { return _this.register(strategy.name, strategy); });
    };
    StrategyIndex.prototype.indexStrategy = function (name, overrideIfExists) {
        if (overrideIfExists === void 0) { overrideIfExists = false; }
        if (StrategyIndex_1.isStrategyRegistered(name) && !overrideIfExists)
            return StrategyIndex_1.get(name);
        var strategy = this.strategies.find(function (strategy) { return strategy.name === name; });
        if (!strategy)
            throw new Error(InvalidStrategyError);
        this.register(name, strategy, overrideIfExists);
        return strategy;
    };
    StrategyIndex.prototype.register = function (name, strategy, overrideIfExists) {
        if (overrideIfExists === void 0) { overrideIfExists = false; }
        if (!StrategyIndex_1.isStrategyRegistered(name) || overrideIfExists) {
            StrategyIndex_1.set(name, strategy);
            this.registration$.next(name);
        }
    };
    var StrategyIndex_1;
    StrategyIndex.index = {};
    StrategyIndex.ctorParameters = function () { return [
        { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [STORAGE_STRATEGIES,] }] }
    ]; };
    StrategyIndex.ɵprov = ɵɵdefineInjectable({ factory: function StrategyIndex_Factory() { return new StrategyIndex(ɵɵinject(STORAGE_STRATEGIES, 8)); }, token: StrategyIndex, providedIn: "root" });
    StrategyIndex = StrategyIndex_1 = __decorate([
        Injectable({ providedIn: 'root' }),
        __param(0, Optional()), __param(0, Inject(STORAGE_STRATEGIES)),
        __metadata("design:paramtypes", [Array])
    ], StrategyIndex);
    return StrategyIndex;
}());

var LocalStorageService = /** @class */ (function (_super) {
    __extends(LocalStorageService, _super);
    function LocalStorageService() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return LocalStorageService;
}(SyncStorage));
function buildService(index) {
    var strategy = index.indexStrategy(StorageStrategies.Local);
    return new SyncStorage(strategy);
}
var LocalStorageServiceProvider = {
    provide: LocalStorageService,
    useFactory: buildService,
    deps: [StrategyIndex]
};

var SessionStorageService = /** @class */ (function (_super) {
    __extends(SessionStorageService, _super);
    function SessionStorageService() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return SessionStorageService;
}(SyncStorage));
function buildService$1(index) {
    var strategy = index.indexStrategy(StorageStrategies.Session);
    return new SyncStorage(strategy);
}
var SessionStorageServiceProvider = {
    provide: SessionStorageService,
    useFactory: buildService$1,
    deps: [StrategyIndex]
};

var DecoratorBuilder = /** @class */ (function () {
    function DecoratorBuilder() {
    }
    DecoratorBuilder.buildSyncStrategyDecorator = function (strategyName, prototype, propName, key, defaultValue) {
        if (defaultValue === void 0) { defaultValue = null; }
        var rawKey = key || propName;
        var storageKey;
        Object.defineProperty(prototype, propName, {
            get: function () {
                var value;
                StrategyIndex.get(strategyName).get(getKey()).subscribe(function (result) { return value = result; });
                return value === undefined ? defaultValue : value;
            },
            set: function (value) {
                StrategyIndex.get(strategyName).set(getKey(), value).subscribe(noop);
            }
        });
        function getKey() {
            if (storageKey !== undefined)
                return storageKey;
            return storageKey = StorageKeyManager.normalize(rawKey);
        }
    };
    return DecoratorBuilder;
}());

function LocalStorage(key, defaultValue) {
    return function (prototype, propName) {
        DecoratorBuilder.buildSyncStrategyDecorator(StorageStrategies.Local, prototype, propName, key, defaultValue);
    };
}
function SessionStorage(key, defaultValue) {
    return function (prototype, propName) {
        DecoratorBuilder.buildSyncStrategyDecorator(StorageStrategies.Session, prototype, propName, key, defaultValue);
    };
}

var Services = [
    LocalStorageServiceProvider,
    SessionStorageServiceProvider
];

var LIB_CONFIG = new InjectionToken('ngx_webstorage_config');
function appInit(index) {
    index.indexStrategies();
    return function () { return StrategyIndex.index; };
}
var NgxWebstorageModule = /** @class */ (function () {
    function NgxWebstorageModule(index, config) {
        if (config)
            StorageKeyManager.consumeConfiguration(config);
        else
            console.error('NgxWebstorage : Possible misconfiguration (The forRoot method usage is mandatory since the 3.0.0)');
    }
    NgxWebstorageModule_1 = NgxWebstorageModule;
    NgxWebstorageModule.forRoot = function (config) {
        if (config === void 0) { config = {}; }
        return {
            ngModule: NgxWebstorageModule_1,
            providers: __spread([
                {
                    provide: LIB_CONFIG,
                    useValue: config,
                },
                LocalStorageProvider,
                SessionStorageProvider
            ], Services, Strategies, [
                {
                    provide: APP_INITIALIZER,
                    useFactory: appInit,
                    deps: [StrategyIndex],
                    multi: true
                }
            ])
        };
    };
    var NgxWebstorageModule_1;
    NgxWebstorageModule.ctorParameters = function () { return [
        { type: StrategyIndex },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [LIB_CONFIG,] }] }
    ]; };
    NgxWebstorageModule = NgxWebstorageModule_1 = __decorate([
        NgModule({}),
        __param(1, Optional()), __param(1, Inject(LIB_CONFIG)),
        __metadata("design:paramtypes", [StrategyIndex, Object])
    ], NgxWebstorageModule);
    return NgxWebstorageModule;
}());

/*
 * Public API Surface of ngx-webstorage
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AsyncStorage, CompatHelper, InMemoryStorageStrategy, InvalidStrategyError, LIB_CONFIG, LOCAL_STORAGE, LocalStorage, LocalStorageService, LocalStorageStrategy, NgxWebstorageModule, SESSION_STORAGE, STORAGE_STRATEGIES, SessionStorage, SessionStorageService, SessionStorageStrategy, StorageStrategies, StorageStrategyStub, StorageStrategyStubName, StorageStub, StrategyCacheService, StrategyIndex, SyncStorage, appInit, getLocalStorage as ɵa, LocalStorageProvider as ɵb, getSessionStorage as ɵc, SessionStorageProvider as ɵd, Strategies as ɵe, buildService as ɵf, LocalStorageServiceProvider as ɵg, buildService$1 as ɵh, SessionStorageServiceProvider as ɵi, BaseSyncStorageStrategy as ɵj, STORAGE_STRATEGIES as ɵl, Services as ɵn };
//# sourceMappingURL=ngx-webstorage.js.map
