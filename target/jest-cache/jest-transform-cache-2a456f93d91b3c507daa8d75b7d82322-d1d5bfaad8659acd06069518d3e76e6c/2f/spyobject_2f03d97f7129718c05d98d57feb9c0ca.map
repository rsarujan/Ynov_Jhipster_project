{"file":"/Users/sarujanrajaratnam/Desktop/Ynov/YNOV_PROJET_BIBLIOTHEQUE_CLEMENCE_SARUJAN/Ynov_TEST_Projet/src/test/javascript/spec/helpers/spyobject.ts","mappings":";;;AAWA,MAAa,SAAS;IACpB,YAAY,IAAU;QACpB,IAAI,IAAI,EAAE;YACR,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;gBACzC,IAAI,CAAC,GAAG,IAAI,CAAC;gBACb,IAAI;oBACF,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;iBAC1B;gBAAC,OAAO,CAAC,EAAE;oBACV,gDAAgD;oBAChD,sEAAsE;oBACtE,sDAAsD;oBACtD,qBAAqB;iBACtB;gBACD,IAAI,OAAO,CAAC,KAAK,UAAU,EAAE;oBAC3B,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;iBAChB;YACH,CAAC,CAAC,CAAC;SACJ;IACH,CAAC;IAED,GAAG,CAAC,IAAY;QACd,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE;YACf,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC,2BAA2B,CAAC,IAAI,CAAC,CAAC;SACrD;QACD,OAAO,IAAI,CAAC,IAAI,CAAC,CAAC;IACpB,CAAC;IAEO,2BAA2B,CAAC,IAAY;QAC9C,MAAM,MAAM,GAAyB,OAAO,CAAC,SAAS,CAAC,IAAI,CAAQ,CAAC;QACpE,MAAM,CAAC,WAAW,GAAG,MAAM,CAAC,GAAG,CAAC,QAAe,CAAC;QAChD,MAAM,CAAC,SAAS,GAAG,MAAM,CAAC,GAAG,CAAC,WAAkB,CAAC;QACjD,MAAM,CAAC,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,KAAY,CAAC;QACzC,gEAAgE;QAChE,MAAM,CAAC,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QAC7B,OAAO,MAAM,CAAC;IAChB,CAAC;CACF;AApCD,8BAoCC","names":[],"sources":["/Users/sarujanrajaratnam/Desktop/Ynov/YNOV_PROJET_BIBLIOTHEQUE_CLEMENCE_SARUJAN/Ynov_TEST_Projet/src/test/javascript/spec/helpers/spyobject.ts"],"sourcesContent":["export interface GuinessCompatibleSpy extends jasmine.Spy {\n  /** By chaining the spy with and.returnValue, all calls to the function will return a specific\n   * value. */\n  andReturn(val: any): GuinessCompatibleSpy;\n  /** By chaining the spy with and.callFake, all calls to the spy will delegate to the supplied\n   * function. */\n  andCallFake(fn: Function): GuinessCompatibleSpy;\n  /** removes all recorded calls */\n  reset(): void;\n}\n\nexport class SpyObject {\n  constructor(type?: any) {\n    if (type) {\n      Object.keys(type.prototype).forEach(prop => {\n        let m = null;\n        try {\n          m = type.prototype[prop];\n        } catch (e) {\n          // As we are creating spys for abstract classes,\n          // these classes might have getters that throw when they are accessed.\n          // As we are only auto creating spys for methods, this\n          // should not matter.\n        }\n        if (typeof m === 'function') {\n          this.spy(prop);\n        }\n      });\n    }\n  }\n\n  spy(name: string): GuinessCompatibleSpy {\n    if (!this[name]) {\n      this[name] = this.createGuinnessCompatibleSpy(name);\n    }\n    return this[name];\n  }\n\n  private createGuinnessCompatibleSpy(name: string): GuinessCompatibleSpy {\n    const newSpy: GuinessCompatibleSpy = jasmine.createSpy(name) as any;\n    newSpy.andCallFake = newSpy.and.callFake as any;\n    newSpy.andReturn = newSpy.and.returnValue as any;\n    newSpy.reset = newSpy.calls.reset as any;\n    // revisit return null here (previously needed for rtts_assert).\n    newSpy.and.returnValue(null);\n    return newSpy;\n  }\n}\n"],"version":3}